package rmq_test

import (
	"context"
	"errors"
	"log"
	"log/slog"
	"os"
	"reflect"
	"time"

	"github.com/danlock/rmq"
	amqp "github.com/rabbitmq/amqp091-go"
)

// Example shows how to write an unsophisticated healthcheck for a service intending to ensure it's rmq.Connection is capable of processing messages.
// Even though rmq.Connection reconnects on errors, there can always be unforeseen networking/DNS/RNGesus issues that necessitate a docker/kubernetes healthcheck
// restarting the service when unhealthy.
func Example() {
	// Real applications should use a real context. If this healthcheck was called via HTTP request for example,
	// that HTTP request's context would be a good candidate.
	ctx := context.TODO()
	// If we want to use a different log library (such as log) instead of log/slog.Log, wrap the function signature instead.
	// If call depth is being logged, think about adding to it so it doesn't just print this log function.
	customLog := func(ctx context.Context, level slog.Level, msg string, args ...any) {
		log.Printf("[%s] trace_id=% msg="+msg, append([]any{level, ctx.Value("your_embedded_trace_id")}, args...)...)
	}
	cfg := rmq.ConnectConfig{Log: customLog}
	// RabbitMQ best practice is to pub and sub on different AMQP connections to avoid TCP backpressure causing issues with message consumption.
	pubRMQConn := rmq.ConnectWithAMQPConfig(ctx, cfg, os.Getenv("TEST_AMQP_URI"), amqp.Config{})
	subRMQConn := rmq.ConnectWithAMQPConfig(ctx, cfg, os.Getenv("TEST_AMQP_URI"), amqp.Config{})

	// Create an AMQP topology for our healthcheck, which uses a temporary exchange and queue. Using x-expires arguments instead may be better in production.
	// Design goals of danlock/rmq include reducing the amount of naked booleans in function signatures forcing you to constantly refer to the docs.
	consCfg := rmq.ConsumerConfig{
		Exchanges:     []rmq.ConsumerExchange{{Name: "healthcheck", Kind: amqp.ExchangeDirect, AutoDelete: true}},
		QueueBindings: []rmq.ConsumerQueueBinding{{ExchangeName: "healthcheck"}},
		// Because rmq.ConsumerQueue lacks a Name, RabbitMQ will auto generate one for us. If you care about the name, generate it yourself.
		// rmq.Consumer intentionally lacks a method to get autogenerated queue names, since they will change between AMQP reconnections.
		Queue:   rmq.ConsumerQueue{AutoDelete: true},
		Qos:     rmq.ConsumerQos{PrefetchCount: 10},
		Consume: rmq.ConsumerConsume{Consumer: "healthchecks-R-us"},
		Log:     slog.Log,
	}

	rmqCons := rmq.NewConsumer(consCfg)
	deliveries := rmqCons.Consume(ctx, subRMQConn)
	// Now we have a queue in rabbit, and messages will be forwarded to the deliveries channel, even if the network drops out temporarily.

	rmqPub := rmq.NewPublisher(ctx, pubRMQConn, rmq.PublisherConfig{Log: slog.Log})
	// With one line we have an AMQP publisher that will resend messages until they are Confirmed or Acked by RabbitMQ.
	// Generate "unique" messages for our healthchecker to check later
	baseMsg := rmq.Publishing{Exchange: consCfg.Exchanges[0].Name, Mandatory: true}
	msgOne := baseMsg
	msgOne.Body = []byte(time.Now().String())
	msgTwo := baseMsg
	msgTwo.Body = []byte(time.Now().String())

	pubCtx, pubCtxCancel := context.WithTimeoutCause(ctx, 10*time.Second, errors.New("He's dead, Jim"))
	defer pubCtxCancel()

	conf, err := rmqPub.PublishUntilConfirmed(pubCtx, 0, msgOne)
	if err != nil {
		panic("uh oh, context timed out?")
	}
	// PublishUntilConfirmed only returns once the amqp.DeferredConfirmation is Done(),
	// so you can check Acked without fear that the return value is simply telling you that it's not Done() yet.
	if !conf.Acked() {
		panic("uh oh, nacked")
	}
	// PublishUntilAcked will resend it on nacks. A Healthcheck may want to do that instead, since restarting the service whenever a nack happens probably won't help.
	if err = rmqPub.PublishUntilAcked(ctx, 0, msgTwo); err != nil {
		panic("uh oh, context timed out?")
	}

	// Now that we've ensure we can send, make sure we can receive.
	for i := 0; i < 2; i++ {
		select {
		case <-time.After(time.Second):
			panic("where's my message?")
		case msg := <-deliveries:
			if !reflect.DeepEqual(msg.Body, msgOne.Body) && !reflect.DeepEqual(msg.Body, msgTwo.Body) {
				panic("realistically this would probably be an error with another instance using this healthcheck simultaenously. Prevent this with a randomized exchange name and/or topic exchange with random routing keys.")
			}
		}
	}

	// We sent and received 2 "unique" messages, so we're probably healthy enough to survive until the next docker/kubernetes health check.
}
